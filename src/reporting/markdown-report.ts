import { Database } from "bun:sqlite";
import { MarkdownOptions } from "../types/reporting";
import { ValidationStatus, Severity } from "../types/config";

export async function generateMarkdownReport(
  db: Database,
  runId: number,
  options: MarkdownOptions
): Promise<string> {
  const { outputPath, maxFailedFiles = 50, includeConfig = false } = options;

  // 1. Fetch Run Info
  const runStmt = db.prepare("SELECT * FROM validation_runs WHERE id = ?");
  const run = runStmt.get(runId) as any;
  
  if (!run) {
    throw new Error(`Run ID ${runId} not found`);
  }

  // 2. Fetch Summary Counts
  const imageStatusStmt = db.prepare(`
    SELECT 
      i.filename,
      MAX(CASE WHEN v.status = 'fail' THEN 1 ELSE 0 END) as is_failed,
      MAX(CASE WHEN v.severity = 'critical' THEN 1 ELSE 0 END) as is_critical
    FROM validation_results v
    JOIN images i ON v.image_id = i.id
    WHERE v.validation_run = ?
    GROUP BY i.id
  `);
  
  const imageStatuses = imageStatusStmt.all(runId) as any[];
  const totalImages = imageStatuses.length;
  const failedImagesCount = imageStatuses.filter(i => i.is_failed).length;
  const passedImagesCount = totalImages - failedImagesCount;
  const passRate = totalImages > 0 ? Math.round((passedImagesCount / totalImages) * 100) : 0;

  // 3. Failures by Severity
  const severityStmt = db.prepare(`
    SELECT severity, COUNT(*) as count 
    FROM validation_results 
    WHERE validation_run = ? AND status = 'fail'
    GROUP BY severity
  `);
  const severityRows = severityStmt.all(runId) as any[];
  const severityMap = new Map<string, number>();
  severityRows.forEach(r => severityMap.set(r.severity, r.count));

  // 4. Failures by Check
  const checkStmt = db.prepare(`
    SELECT check_type, COUNT(*) as count
    FROM validation_results
    WHERE validation_run = ? AND status = 'fail'
    GROUP BY check_type
  `);
  const checkRows = checkStmt.all(runId) as any[];

  // 5. Failed Files Details
  const failedFilesStmt = db.prepare(`
    SELECT i.filename, v.check_type, v.severity, v.message
    FROM validation_results v
    JOIN images i ON v.image_id = i.id
    WHERE v.validation_run = ? AND v.status = 'fail'
    ORDER BY v.severity DESC, i.filename ASC
    LIMIT ?
  `);
  
  const failedDetails = failedFilesStmt.all(runId, maxFailedFiles * 10) as any[];
  
  const criticalFailures = failedDetails.filter(r => r.severity === 'critical');
  const fixableFailures = failedDetails.filter(r => r.severity === 'fixable');
  
  // Build Markdown
  let md = `# Validation Report\n\n`;
  md += `**Run:** v${run.version}\n`;
  md += `**Date:** ${run.started_at}\n`;
  md += `**Images:** ${totalImages}\n\n`;

  md += `## Summary\n\n`;
  md += `| Status | Count | Percentage |\n`;
  md += `|--------|-------|------------|\n`;
  md += `| ✓ Passed | ${passedImagesCount} | ${passRate}% |\n`;
  md += `| ✗ Failed | ${failedImagesCount} | ${100 - passRate}% |\n\n`;

  md += `## Failures by Severity\n\n`;
  md += `- **Critical:** ${severityMap.get('critical') || 0}\n`;
  md += `- **Fixable:** ${severityMap.get('fixable') || 0}\n`;
  md += `- **Warnings:** ${severityMap.get('warning') || 0}\n\n`;

  md += `## Failures by Check\n\n`;
  md += `| Check | Failed | \n`;
  md += `|-------|--------|\n`;
  for (const row of checkRows) {
    md += `| ${row.check_type} | ${row.count} |\n`;
  }
  md += `\n`;

  if (failedImagesCount > 0) {
    md += `## Failed Files\n\n`;
    
    if (criticalFailures.length > 0) {
      md += `### Critical (${criticalFailures.length})\n\n`;
      md += `| File | Issue |\n`;
      md += `|------|-------|\n`;
      criticalFailures.slice(0, maxFailedFiles).forEach(f => {
        md += `| ${f.filename} | ${f.message} |\n`;
      });
      if (criticalFailures.length > maxFailedFiles) md += `| ... | ... |\n`;
      md += `\n`;
    }

    if (fixableFailures.length > 0) {
      md += `### Fixable (${fixableFailures.length})\n\n`;
      md += `| File | Issue |\n`;
      md += `|------|-------|\n`;
      fixableFailures.slice(0, maxFailedFiles).forEach(f => {
        md += `| ${f.filename} | ${f.message} |\n`;
      });
      if (fixableFailures.length > maxFailedFiles) md += `| ... | ... |\n`;
      md += `\n`;
    }
  }

  if (includeConfig) {
    md += `## Configuration\n\n`;
    md += "```yaml\n";
    try {
      const configContent = await Bun.file('project-spec.yaml').text();
      md += configContent;
    } catch (e) {
      md += `# Config file not found or could not be read.\n`;
    }
    md += "\n```\n";
  }

  md += `\n---\n*Generated by Heritage QC*`;

  await Bun.write(outputPath, md);
  return outputPath;
}